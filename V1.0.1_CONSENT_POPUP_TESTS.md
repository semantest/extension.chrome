# Automated Test Suite v1.0.1 - Privacy Consent Popup

**Version**: 1.0.1  
**Created**: July 21, 2025  
**Priority**: CRITICAL - Chrome Web Store Compliance Requirement  
**Focus**: Privacy consent popup verification

## 🚨 Critical Requirements

The privacy consent popup is **MANDATORY** for Chrome Web Store approval when collecting telemetry data. This test suite ensures full compliance with Google's privacy policies.

---

## 📋 Test Coverage Overview

### Core Test Areas
1. **Consent Popup Appearance** - Fresh install detection
2. **User Choice Persistence** - Decision storage and respect
3. **Privacy Compliance** - Data collection behavior
4. **Error Handling** - Graceful degradation
5. **Migration Testing** - Existing user upgrades

---

## 🧪 Automated Test Implementation

### 1. Consent Popup Appearance Tests

```javascript
// tests/privacy/consent-popup-appearance.test.js
describe('Privacy Consent Popup - Appearance Tests', () => {
  
  beforeEach(async () => {
    // Clear all storage to simulate fresh install
    await chrome.storage.local.clear();
    await chrome.storage.sync.clear();
    await clearIndexedDB();
  });
  
  test('Shows consent popup on first extension load', async () => {
    // Simulate fresh install
    await browser.runtime.install();
    
    // Wait for popup notification
    const notification = await waitForNotification({
      type: 'basic',
      title: 'Privacy Notice',
      timeout: 5000
    });
    
    expect(notification).toBeDefined();
    expect(notification.title).toBe('Privacy Notice - SemanTest Extension');
    expect(notification.message).toContain('telemetry');
    expect(notification.buttons).toHaveLength(2);
    expect(notification.buttons[0].title).toBe('Allow');
    expect(notification.buttons[1].title).toBe('Deny');
  });
  
  test('Does NOT show popup if consent already given', async () => {
    // Set prior consent
    await chrome.storage.local.set({
      'privacy.telemetryConsent': true,
      'privacy.consentTimestamp': Date.now()
    });
    
    // Reload extension
    await browser.runtime.reload();
    
    // Verify no notification appears
    const notification = await waitForNotification({
      timeout: 3000,
      expectNone: true
    });
    
    expect(notification).toBeNull();
  });
  
  test('Shows popup again if consent data is corrupted', async () => {
    // Set invalid consent data
    await chrome.storage.local.set({
      'privacy.telemetryConsent': 'invalid', // Should be boolean
      'privacy.consentTimestamp': 'not-a-timestamp'
    });
    
    await browser.runtime.reload();
    
    const notification = await waitForNotification({
      type: 'basic',
      timeout: 5000
    });
    
    expect(notification).toBeDefined();
    expect(notification.title).toBe('Privacy Notice - SemanTest Extension');
  });
  
  test('Popup appears within 3 seconds of install', async () => {
    const startTime = Date.now();
    
    await browser.runtime.install();
    
    const notification = await waitForNotification({
      type: 'basic',
      timeout: 5000
    });
    
    const elapsed = Date.now() - startTime;
    expect(elapsed).toBeLessThan(3000);
  });
});
```

### 2. User Choice Persistence Tests

```javascript
// tests/privacy/consent-choice-persistence.test.js
describe('Privacy Consent - User Choice Persistence', () => {
  
  test('Saves "Allow" choice correctly', async () => {
    // Show consent popup
    await browser.runtime.install();
    const notification = await waitForNotification();
    
    // Click "Allow"
    await chrome.notifications.onButtonClicked.dispatch(
      notification.id, 
      0 // First button = Allow
    );
    
    // Verify storage
    const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
    expect(consent['privacy.telemetryConsent']).toBe(true);
    
    // Verify timestamp
    const timestamp = await chrome.storage.local.get(['privacy.consentTimestamp']);
    expect(timestamp['privacy.consentTimestamp']).toBeGreaterThan(Date.now() - 1000);
  });
  
  test('Saves "Deny" choice correctly', async () => {
    // Show consent popup
    await browser.runtime.install();
    const notification = await waitForNotification();
    
    // Click "Deny"
    await chrome.notifications.onButtonClicked.dispatch(
      notification.id,
      1 // Second button = Deny
    );
    
    // Verify storage
    const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
    expect(consent['privacy.telemetryConsent']).toBe(false);
  });
  
  test('Choice persists across browser restarts', async () => {
    // Set consent
    await chrome.storage.local.set({
      'privacy.telemetryConsent': false,
      'privacy.consentTimestamp': Date.now()
    });
    
    // Simulate browser restart
    await browser.restart();
    
    // Verify consent still exists
    const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
    expect(consent['privacy.telemetryConsent']).toBe(false);
    
    // Verify no new popup
    const notification = await waitForNotification({
      timeout: 3000,
      expectNone: true
    });
    expect(notification).toBeNull();
  });
  
  test('Choice syncs across devices when using Chrome sync', async () => {
    // Enable Chrome sync
    await chrome.storage.sync.set({
      'privacy.telemetryConsent': true,
      'privacy.consentTimestamp': Date.now()
    });
    
    // Simulate device change
    await simulateDeviceChange();
    
    // Verify sync data available
    const syncConsent = await chrome.storage.sync.get(['privacy.telemetryConsent']);
    expect(syncConsent['privacy.telemetryConsent']).toBe(true);
  });
});
```

### 3. Privacy Compliance Verification Tests

```javascript
// tests/privacy/consent-compliance.test.js
describe('Privacy Compliance - Telemetry Behavior', () => {
  
  beforeEach(async () => {
    // Mock telemetry reporter
    jest.spyOn(window.errorReporter, 'reportFeatureUsage');
    jest.spyOn(window.errorReporter, 'reportError');
  });
  
  test('NO telemetry sent before consent decision', async () => {
    // Fresh install, no consent yet
    await chrome.storage.local.clear();
    
    // Trigger feature that would normally send telemetry
    await controller.createProject('Test Project');
    
    // Verify no telemetry sent
    expect(window.errorReporter.reportFeatureUsage).not.toHaveBeenCalled();
    expect(window.errorReporter.reportError).not.toHaveBeenCalled();
  });
  
  test('Telemetry sent ONLY after user allows', async () => {
    // Set consent to true
    await chrome.storage.local.set({
      'privacy.telemetryConsent': true,
      'privacy.consentTimestamp': Date.now()
    });
    
    // Trigger feature
    await controller.createProject('Test Project');
    
    // Verify telemetry was sent
    expect(window.errorReporter.reportFeatureUsage).toHaveBeenCalledWith(
      'create_project',
      true,
      expect.any(Object)
    );
  });
  
  test('NO telemetry sent when user denies', async () => {
    // Set consent to false
    await chrome.storage.local.set({
      'privacy.telemetryConsent': false,
      'privacy.consentTimestamp': Date.now()
    });
    
    // Trigger multiple features
    await controller.createProject('Test Project');
    await controller.sendPrompt('Test prompt');
    await controller.setCustomInstructions('User', 'Model');
    
    // Verify no telemetry sent
    expect(window.errorReporter.reportFeatureUsage).not.toHaveBeenCalled();
    expect(window.errorReporter.reportError).not.toHaveBeenCalled();
  });
  
  test('Error reporting respects consent', async () => {
    // Deny consent
    await chrome.storage.local.set({
      'privacy.telemetryConsent': false
    });
    
    // Trigger an error
    try {
      await controller.createProject(null); // Invalid input
    } catch (error) {
      // Error should be caught but not reported
    }
    
    // Verify error not reported
    expect(window.errorReporter.reportError).not.toHaveBeenCalled();
  });
  
  test('Consent change takes effect immediately', async () => {
    // Start with consent allowed
    await chrome.storage.local.set({
      'privacy.telemetryConsent': true
    });
    
    // Send telemetry
    await controller.createProject('Project 1');
    expect(window.errorReporter.reportFeatureUsage).toHaveBeenCalledTimes(1);
    
    // Change to denied
    await chrome.storage.local.set({
      'privacy.telemetryConsent': false
    });
    
    // Try to send more telemetry
    await controller.createProject('Project 2');
    
    // Verify no additional telemetry sent
    expect(window.errorReporter.reportFeatureUsage).toHaveBeenCalledTimes(1);
  });
});
```

### 4. Migration and Edge Case Tests

```javascript
// tests/privacy/consent-migration.test.js
describe('Privacy Consent - Migration & Edge Cases', () => {
  
  test('Existing v1.0.0 users see consent popup on upgrade', async () => {
    // Simulate v1.0.0 data (no consent stored)
    await chrome.storage.local.set({
      'version': '1.0.0',
      'projects': ['Project 1', 'Project 2'],
      'settings': { theme: 'light' }
    });
    
    // Upgrade to v1.0.1
    await browser.runtime.update('1.0.1');
    
    // Verify popup appears
    const notification = await waitForNotification({
      type: 'basic',
      timeout: 5000
    });
    
    expect(notification).toBeDefined();
    expect(notification.title).toContain('Privacy Notice');
  });
  
  test('Handles notification API unavailable gracefully', async () => {
    // Disable notifications API
    chrome.notifications = undefined;
    
    // Install extension
    await browser.runtime.install();
    
    // Should fallback to browser action popup
    const popup = await browser.action.getPopup();
    expect(popup).toContain('privacy-consent.html');
  });
  
  test('Handles storage quota exceeded', async () => {
    // Fill storage to near quota
    const largeData = 'x'.repeat(4 * 1024 * 1024); // 4MB
    await chrome.storage.local.set({ 'large': largeData });
    
    // Try to save consent
    const result = await saveConsentChoice(true);
    
    // Should handle gracefully
    expect(result.success).toBe(true);
    expect(result.fallback).toBe('sync'); // Falls back to sync storage
  });
  
  test('Consent UI accessible via keyboard only', async () => {
    // Open consent dialog
    const dialog = await openConsentDialog();
    
    // Tab to Allow button
    await browser.keyboard.press('Tab');
    await browser.keyboard.press('Tab');
    
    // Verify focus on Allow button
    const focusedElement = await dialog.evaluate(() => document.activeElement.textContent);
    expect(focusedElement).toBe('Allow');
    
    // Press Enter to select
    await browser.keyboard.press('Enter');
    
    // Verify consent saved
    const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
    expect(consent['privacy.telemetryConsent']).toBe(true);
  });
});
```

### 5. Performance and Reliability Tests

```javascript
// tests/privacy/consent-performance.test.js
describe('Privacy Consent - Performance & Reliability', () => {
  
  test('Consent check adds <10ms to startup time', async () => {
    // Measure startup without consent check
    const baselineStart = performance.now();
    await initializeExtensionWithoutConsent();
    const baselineTime = performance.now() - baselineStart;
    
    // Measure startup with consent check
    const consentStart = performance.now();
    await initializeExtensionWithConsent();
    const consentTime = performance.now() - consentStart;
    
    const overhead = consentTime - baselineTime;
    expect(overhead).toBeLessThan(10);
  });
  
  test('Consent storage uses <1KB', async () => {
    // Save consent
    await saveConsentChoice(true);
    
    // Measure storage usage
    const usage = await chrome.storage.local.getBytesInUse(['privacy.telemetryConsent', 'privacy.consentTimestamp']);
    
    expect(usage).toBeLessThan(1024); // Less than 1KB
  });
  
  test('Handles rapid consent changes', async () => {
    // Rapidly toggle consent
    for (let i = 0; i < 10; i++) {
      await saveConsentChoice(i % 2 === 0);
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    // Verify final state is correct
    const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
    expect(consent['privacy.telemetryConsent']).toBe(false); // Last was false
  });
  
  test('Consent popup doesn\'t block extension functionality', async () => {
    // Fresh install
    await browser.runtime.install();
    
    // Don't respond to consent popup
    // Meanwhile, try to use extension
    const projectResult = await controller.createProject('Test While Popup Open');
    
    // Should work but without telemetry
    expect(projectResult.success).toBe(true);
    expect(window.errorReporter.reportFeatureUsage).not.toHaveBeenCalled();
  });
});
```

---

## 🔧 Test Infrastructure

### Mock Implementations

```javascript
// tests/mocks/consent-mocks.js
class ConsentMockHelpers {
  static async simulateFreshInstall() {
    await chrome.storage.local.clear();
    await chrome.storage.sync.clear();
    delete window.consentGiven;
  }
  
  static async waitForNotification(options = {}) {
    const { 
      timeout = 5000, 
      expectNone = false,
      type = 'basic' 
    } = options;
    
    return new Promise((resolve) => {
      let resolved = false;
      
      const listener = (notificationId, notificationOptions) => {
        if (!resolved && notificationOptions.type === type) {
          resolved = true;
          chrome.notifications.onCreated.removeListener(listener);
          resolve({ id: notificationId, ...notificationOptions });
        }
      };
      
      chrome.notifications.onCreated.addListener(listener);
      
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          chrome.notifications.onCreated.removeListener(listener);
          resolve(expectNone ? null : undefined);
        }
      }, timeout);
    });
  }
  
  static async saveConsentChoice(allowed) {
    try {
      await chrome.storage.local.set({
        'privacy.telemetryConsent': allowed,
        'privacy.consentTimestamp': Date.now()
      });
      return { success: true };
    } catch (error) {
      // Try sync storage as fallback
      try {
        await chrome.storage.sync.set({
          'privacy.telemetryConsent': allowed,
          'privacy.consentTimestamp': Date.now()
        });
        return { success: true, fallback: 'sync' };
      } catch (syncError) {
        return { success: false, error: syncError.message };
      }
    }
  }
}
```

### Test Configuration

```javascript
// jest.config.privacy.js
module.exports = {
  displayName: 'Privacy Consent Tests',
  testMatch: [
    '**/tests/privacy/**/*.test.js'
  ],
  setupFilesAfterEnv: [
    '<rootDir>/tests/mocks/chrome-api-mocks.js',
    '<rootDir>/tests/mocks/consent-mocks.js'
  ],
  testEnvironment: 'jsdom',
  testTimeout: 30000,
  coverageThreshold: {
    'src/privacy/': {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  }
};
```

---

## 📋 Manual Verification Checklist

### Critical Path Testing
```markdown
## Fresh Install Test
1. [ ] Uninstall any existing version
2. [ ] Clear Chrome profile data
3. [ ] Install v1.0.1 extension
4. [ ] **VERIFY**: Consent popup appears within 3 seconds
5. [ ] **VERIFY**: Popup has clear Allow/Deny buttons
6. [ ] Click "Allow"
7. [ ] **VERIFY**: No popup on reload
8. [ ] **VERIFY**: Telemetry is being sent

## Upgrade Test
1. [ ] Install v1.0.0 (without consent)
2. [ ] Use extension normally
3. [ ] Upgrade to v1.0.1
4. [ ] **VERIFY**: Consent popup appears
5. [ ] **VERIFY**: Existing data preserved

## Privacy Test
1. [ ] Fresh install
2. [ ] Click "Deny" on consent popup
3. [ ] Use all 6 features
4. [ ] **VERIFY**: No network requests to telemetry endpoint
5. [ ] **VERIFY**: No errors in console
```

---

## 🚀 CI/CD Integration

### GitHub Actions Workflow

```yaml
# .github/workflows/privacy-consent-tests.yml
name: Privacy Consent Test Suite

on:
  push:
    branches: [v1.0.1-release]
  pull_request:
    paths:
      - 'src/privacy/**'
      - 'tests/privacy/**'

jobs:
  consent-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Chrome for testing
      uses: browser-actions/setup-chrome@latest
      with:
        chrome-version: 'stable'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run privacy consent tests
      run: npm run test:privacy:consent
      env:
        HEADLESS: false  # Consent UI needs real browser
    
    - name: Check coverage
      run: npm run coverage:privacy
      
    - name: Upload results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: privacy-test-results
        path: coverage/privacy/
```

---

## 🎯 Success Criteria

### Must Pass (Chrome Web Store Requirements)
1. ✅ Consent popup appears on first install
2. ✅ User can clearly choose Allow or Deny
3. ✅ Choice is persisted and respected
4. ✅ No telemetry sent without consent
5. ✅ Consent UI is accessible

### Should Pass (Quality Standards)
1. ✅ Performance impact <10ms
2. ✅ Handles edge cases gracefully
3. ✅ Works across all Chrome versions
4. ✅ Clear privacy policy link
5. ✅ Consent change takes effect immediately

---

## 🔍 Debugging Guide

### Common Issues

**Popup Not Appearing**:
```javascript
// Check if consent already stored
const consent = await chrome.storage.local.get(['privacy.telemetryConsent']);
console.log('Existing consent:', consent);

// Force reset for testing
await chrome.storage.local.remove(['privacy.telemetryConsent', 'privacy.consentTimestamp']);
```

**Telemetry Still Sending After Deny**:
```javascript
// Verify consent check in telemetry code
if (window.errorReporter) {
  console.log('Consent required:', window.errorReporter.isConsentRequired());
  console.log('Has consent:', window.errorReporter.hasConsent());
}
```

---

## 📊 Test Metrics

### Coverage Requirements
- **Consent UI Logic**: 100% coverage required
- **Storage Operations**: 100% coverage required  
- **Telemetry Gating**: 100% coverage required
- **Error Paths**: 90% coverage minimum

### Performance Benchmarks
- Consent check: <10ms overhead
- Storage operation: <5ms
- UI render: <100ms
- Total impact: <200ms on startup

---

*This test suite ensures v1.0.1 meets all Chrome Web Store privacy requirements while maintaining excellent user experience.*